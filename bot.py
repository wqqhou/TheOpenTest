# Logging module
import logging
import sentry_sdk

# Aiogram imports
from aiogram import Bot, Dispatcher, types
from aiogram.dispatcher.filters import Text
from aiogram.types import ParseMode, ReplyKeyboardMarkup, KeyboardButton
from aiogram.contrib.fsm_storage.memory import MemoryStorage
from aiogram.dispatcher import FSMContext
from aiogram.dispatcher.filters.state import State, StatesGroup
from aiogram.utils import executor

# Local modules to work with Database and Ton network
import config
import ton
import db
import key
import withdrawl

import codecs
import qrcode
import base64
import time
import requests

import nacl
from nacl.bindings import crypto_sign, crypto_sign_BYTES
from nacl.signing import SignedMessage

sentry_sdk.init(
    dsn="https://31f715d7ba61cef76e24188d19e6ebfb@o4506132003684352.ingest.sentry.io/4506132013776896",
    enable_tracing=True
)

def bytes_to_b64str(bytes_arr):
    return codecs.decode(codecs.encode(
        bytes_arr, "base64"), 'utf-8').replace("\n", '')

def sign_message(message: bytes,
                 signing_key,
                 encoder: nacl.encoding.Encoder = nacl.encoding.RawEncoder, ) -> SignedMessage:
    raw_signed = crypto_sign(message, signing_key)

    signature = encoder.encode(raw_signed[:crypto_sign_BYTES])
    message = encoder.encode(raw_signed[crypto_sign_BYTES:])
    signed = encoder.encode(raw_signed)
    signature = base64.b64encode(signature)
    signature = bytes_to_b64str(signature)
    return signature, message


# Now all the info about bot work will be printed out to console
logging.basicConfig(level=logging.INFO)

# Initialize the bot and dispatcher
bot = Bot(token=config.BOT_TOKEN)
storage = MemoryStorage()
dp = Dispatcher(bot, storage=storage)
class Form(StatesGroup):
        use = State()
        ask_nft = State()
        ask_addr = State()



@dp.message_handler(commands=['start', 'help'])
async def welcome_handler(message: types.Message):
    # Function that sends the welcome message with main keyboard to user

    uid = message.from_user.id  # Not neccessary, just to make code shorter

    # If user doesn't exist in database, insert it
    if not db.check_user(uid):
        db.add_user(uid)

    # Keyboard with two main buttons: Deposit and Balance
    keyboard = ReplyKeyboardMarkup(resize_keyboard=True)
    keyboard.row(KeyboardButton('Register'), KeyboardButton('Deposit NFT'))
    keyboard.row(KeyboardButton('NFT List'), KeyboardButton('View/Use NFT'))
    keyboard.row(KeyboardButton('View Uid'), KeyboardButton('NFT Withdrawal'))

    # Send welcome text and include the keyboard
    await message.answer('Hi there!\n\nI am the open test bot. '
                         'You can call me TOT bot as well.\n'
                         'Type or click Register and send a small amount transaction to us with your uid as the comment.\n\n'
                         'Then your address will be recorded and you can use that address to deposit NFTs.\n\n'
                         'This bot is still in beta testing stage, we are not responsible for any damage and/or lost incurred directly/indirectly related to this bot. Use it at your own discretion.\n\n'                        
                         'More info: https://theopenpass.io',
                         reply_markup=keyboard,
                         parse_mode=ParseMode.MARKDOWN)


@dp.message_handler(state='*', commands='cancel')
@dp.message_handler(Text(equals='cancel', ignore_case=True), state='*')
async def cancel_handler(message: types.Message, state: FSMContext):

    current_state = await state.get_state()
    if current_state is None:
        return
    logging.info('Cancelling state %r', current_state)
    # Cancel state and inform user about it
    await state.finish()
    # And remove keyboard (just in case)
    await message.answer('Cancelled.')

@dp.message_handler(commands='NFT List')
@dp.message_handler(Text(equals='NFT List', ignore_case=True))
async def balance_handler(message: types.Message):
    # Function that shows user his current balance

    uid = message.from_user.id

    # Get user balance from database
    # Also don't forget that 1 TON = 1e9 (billion) NanoTON
    user_nft = str(db.get_nft(uid))
    user_nft = user_nft.split('se@pa@ra$to$r ')
    n = 1
    final_list = ""
    for x in user_nft:
        if x == "0x00":
            continue
        x = x = str(n) + '. ' + x + '\n'
        final_list = final_list + x
        n = n + 1
    if len(final_list) > 2:
        await message.answer(f'Your nft list: *{final_list}*',
                             parse_mode=ParseMode.MARKDOWN)
    else:
        await message.answer(f"You don't have any NFT currently.",
                             parse_mode=ParseMode.MARKDOWN)


@dp.message_handler(commands='View Uid')
@dp.message_handler(Text(equals='View Uid', ignore_case=True))
async def deposit_handler(message: types.Message):

    uid = message.from_user.id

    await message.answer('Your uid:',
                         parse_mode=ParseMode.MARKDOWN)
    await message.answer(f'{uid}',
                         parse_mode=ParseMode.MARKDOWN)

@dp.message_handler(commands='Register')
@dp.message_handler(Text(equals='Register', ignore_case=True))
async def deposit_handler(message: types.Message):
    # Function that gives user the address to deposit

    uid = message.from_user.id

    # Keyboard with deposit URL


    # Send text that explains how to make a deposit into bot to user
    await message.answer('Send a 0(or tiny) amount transaction to this address:\n\n'
                         f'`{config.DEPOSIT_ADDRESS}`\n\n'
                         f'And include the following comment: `{uid}`\n\n'
                         'You will recieve a confirmation message after we recorded your registration',
                         parse_mode=ParseMode.MARKDOWN)

@dp.message_handler(commands='Deposit NFT')
@dp.message_handler(Text(equals='Deposit NFT', ignore_case=True))
async def deposit_handler(message: types.Message):
    # Function that gives user the address to deposit

    uid = message.from_user.id

    # Keyboard with deposit URL


    # Send text that explains how to make a deposit into bot to user
    await message.answer('Make sure you only send NFTs to this address from a registered address.\n\n'
                         f'Deposit address:\n\n'
                         f'`{config.DEPOSIT_ADDRESS}`\n\n'
                         'You will recieve a confirmation message after we receive your NFT. You can also use NFT list to check.',
                         parse_mode=ParseMode.MARKDOWN)

@dp.message_handler(commands='NFT Withdrawal')
@dp.message_handler(Text(equals='NFT Withdrawal', ignore_case=True))
async def balance_handler(message: types.Message):
    # Function that shows user his current balance

    uid = message.from_user.id

    # Format balance and send to user
    await message.answer(f'Tell me which NFT you would like to withdrawal by input its sequence number in your NFT list. (e.g. 1 or 2)\n\n(or type cancel to cancel this action.)',
                         parse_mode=ParseMode.MARKDOWN)
    await Form.ask_nft.set()

@dp.message_handler(state=Form.ask_nft)
async def balance_handler(message: types.Message, state: FSMContext):
    uid = message.from_user.id
    if message.text.isdigit():
        if message.text != 0:
            try:
                db.check_seqno(uid, int(message.text))
                with open(f'{uid}.txt', 'w') as f:
                    f.write(str(message.text))
                await message.answer(f'Tell me the desired withdrawal address.\n\n(or type cancel to cancel this action.)',
                                     parse_mode=ParseMode.MARKDOWN)
                await Form.next()
            except:
                await message.answer(f'Try again. Please input a valid number.\n\n(or type cancel to cancel this action.)',
                                 parse_mode=ParseMode.MARKDOWN) 
        else:
            await message.answer(f'Try again. Please input a valid number.\n\n(or type cancel to cancel this action.)',
                                 parse_mode=ParseMode.MARKDOWN)            
    else:
        await message.answer(f'Try again. Please input number only.\n\n(or type cancel to cancel this action.)',
                             parse_mode=ParseMode.MARKDOWN)
@dp.message_handler(state=Form.ask_addr)
async def balance_handler(message: types.Message, state: FSMContext):
    uid = message.from_user.id
    with open(f'{uid}.txt', 'r') as f:
        seqno = int(f.read())
    nft, nft_name, nft_des, nft_img_url = db.get_one(uid, seqno)
    tx_hash = withdrawl.withdrawl(message.text, nft)
    if tx_hash:
        db.delete_one(uid, seqno)
        await message.answer(f'Transaction sent. TXID: {tx_hash}',
                         parse_mode=ParseMode.MARKDOWN)
        await state.finish()
    else:
        await message.answer(f'Try again. Please input a valid address.\n\n(or type cancel to cancel this action.)',
                            parse_mode=ParseMode.MARKDOWN) 

        


@dp.message_handler(commands='View/Use NFT')
@dp.message_handler(Text(equals='View/Use NFT', ignore_case=True))
async def balance_handler(message: types.Message):
    # Function that shows user his current balance

    uid = message.from_user.id

    # Format balance and send to user
    await message.answer(f'Tell me which NFT you would like to view or use by input its sequence number in your NFT list. (e.g. 1 or 2)\n\n(or type cancel to cancel this action.)',
                         parse_mode=ParseMode.MARKDOWN)
    await Form.use.set()

@dp.message_handler(state=Form.use)
async def balance_handler(message: types.Message, state: FSMContext):
    uid = message.from_user.id
    if message.text.isdigit():
        if int(message.text) != 0:
            uid = message.from_user.id
            seqno = int(message.text)
            try:
                answer, nft_name, nft_des, nft_img_url = db.get_one(uid, seqno)
                answer = answer + "TimeStamp" + str(time.time())
                sig = sign_message(bytes(answer, 'utf-8'), key.mnemonic_to_key(config.MNEMONIC)[1])
                img = qrcode.make(sig)
                img.save(f"/root/temp_files/ValidFor_1_Minute_{uid}.png")
                nft_img = requests.get(nft_img_url)
                nft_detail = "Name: " + nft_name + "\nDescription:\n" + nft_des
                try:
                    if nft_img.headers['content-type'] == 'image/gif' or nft_img.headers['content-type'] == 'video/mp4':
                        await bot.send_animation(message.chat.id, animation = nft_img_url, caption = nft_detail)
                    else:
                        await bot.send_photo(message.chat.id, photo = nft_img.content, caption = nft_detail)
                except: 
                    await bot.send_message(uid, f'Error retrieving image, file too large or not supported.\n{nft_detail}', parse_mode=ParseMode.HTML)
                
                await bot.send_document(message.chat.id, open(f'/root/temp_files/ValidFor_1_Minute_{uid}.png','rb' ))
                await state.finish()
            except:
                await message.answer(f'Try again. Please input a valid number.\n\n(or type cancel to cancel this action.)',
                             parse_mode=ParseMode.MARKDOWN)              
        else:
            await message.answer(f'Try again. Please input valid number.\n\n(or type cancel to cancel this action.)',
                             parse_mode=ParseMode.MARKDOWN)            
    else:
        await message.answer(f'Try again. Please input number only.\n\n(or type cancel to cancel this action.)',
                             parse_mode=ParseMode.MARKDOWN)

if __name__ == '__main__':
    # Create Aiogram executor for our bot
    ex = executor.Executor(dp)

    # Launch the deposit waiter with our executor
    ex.loop.create_task(ton.start())

    # Launch the bot
    ex.start_polling()
