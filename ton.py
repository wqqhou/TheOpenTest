# Requests for API, Asyncio to call sleep() in async func
import requests
import asyncio
import base64
import sentry_sdk

# Aiogram
from aiogram import Bot
from aiogram.types import ParseMode

# We also need config and database here
import config
import db

sentry_sdk.init(
    dsn="https://31f715d7ba61cef76e24188d19e6ebfb@o4506132003684352.ingest.sentry.io/4506132013776896",
    enable_tracing=True
)

bounceable_tag, non_bounceable_tag = b'\x11', b'\x51'
b64_abc = set(
    'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890+/')
b64_abc_urlsafe = set(
    'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890_-')


def calcCRC(message):
    poly = 0x1021
    reg = 0
    message += b'\x00\x00'
    for byte in message:
        mask = 0x80
        while(mask > 0):
            reg <<= 1
            if byte & mask:
                reg += 1
            mask >>= 1
            if reg > 0xffff:
                reg &= 0xffff
                reg ^= poly
    return reg.to_bytes(2, "big")


def account_forms(raw_form, test_only=False):
    workchain, address = raw_form.split(":")
    workchain, address = int(workchain), int(address, 16)
    address = address.to_bytes(32, "big")
    workchain_tag = b'\xff' if workchain == - \
        1 else workchain.to_bytes(1, "big")
    btag = bounceable_tag
    nbtag = non_bounceable_tag
    # if test_only:
    #  btag = (btag[0] | 0x80).to_bytes(1,'big')
    #  nbtag = (nbtag[0] | 0x80).to_bytes(1,'big')
    preaddr_b = btag + workchain_tag + address
    preaddr_u = nbtag + workchain_tag + address
    b64_b = base64.b64encode(preaddr_b+calcCRC(preaddr_b)).decode('utf8')
    b64_u = base64.b64encode(preaddr_u+calcCRC(preaddr_u)).decode('utf8')
    b64_b_us = base64.urlsafe_b64encode(
        preaddr_b+calcCRC(preaddr_b)).decode('utf8')
    b64_u_us = base64.urlsafe_b64encode(
        preaddr_u+calcCRC(preaddr_u)).decode('utf8')
    return b64_b_us

async def start():
    # Function that is checking our wallet for new deposits and process them

    try:
        # Try to load last_lt from file
        with open('last_lt.txt', 'r') as f:
            last_lt = int(f.read())
    except FileNotFoundError:
        # If file not found, set last_lt to 0
        last_lt = 0

    try:
        # Try to load last_lt from file
        with open('last_lt_nft.txt', 'r') as f:
            last_lt_nft = int(f.read())
    except FileNotFoundError:
        # If file not found, set last_lt to 0
        last_lt_nft = 0

    # We need the Bot instance here to send deposit notifications to users
    bot = Bot(token=config.BOT_TOKEN)

    while True:
        # 2 Seconds delay between checks
        await asyncio.sleep(2)

        # API call to Toncenter that returns last 100 transactions of our wallet
        try:
            resp = requests.get(f'{config.API_BASE_URL}/api/v2/getTransactions?'
                                f'address={config.DEPOSIT_ADDRESS}&limit=100&'
                                f'archival=true&api_key={config.API_KEY}').json()

            nft_resp = requests.get(f'https://tonapi.io/v2/accounts/{config.DEPOSIT_ADDRESS}/events?'
                                    f'account_id={config.DEPOSIT_ADDRESS}&limit=1000&'
                                    f'api_key= "{config.TON_API_KEY}"').json()
        # If call was not successful, try again
            if not resp['ok']:
                    continue

        # Iterating over transactions
            for tx in resp['result']:
                # LT is Logical Time and Hash is hash of our transaction
                lt, hash = int(tx['transaction_id']['lt']), tx['transaction_id']['hash']

            # If this transaction's logical time is lower than our last_lt,
            # we already processed it, so skip it
 
                if lt <= last_lt:
                    continue

            # Get value of transaction (how much NanoTONs have we received)
                value = int(tx['in_msg']['value'])
                if value >= 0:
                    # If value is greater than 0, it is probably a new deposit and
                    # we must process it by increasing someone's balance in database
                    uid = tx['in_msg']['message']
                    new_addr = str(tx['in_msg']['source'])

                # If transaction comment isn't a number, skip it
                    if not uid.isdigit():
                        continue

                    uid = int(uid)
    
                    if not db.check_user(uid):
                        continue

                # Here 'message' is a existing user's ID
                # and 'value' is deposit amount

                # Increase user's balance in database
                    db.reg_addr(new_addr, uid)

                # Send a message to user
                    await bot.send_message(uid, 'Address registered! Now you can use this address for NFT deposit\n'
                                          f'* "{new_addr}" *',
                                          parse_mode=ParseMode.MARKDOWN)
                last_lt = lt
                with open('last_lt.txt', 'w') as f:
                    f.write(str(last_lt))

            for ev in nft_resp['events']:
            # LT is Logical Time and Hash is hash of our transaction
                lt_nft = int(ev['lt'])

            # If this transaction's logical time is lower than our last_lt,
            # we already processed it, so skip it

                if lt_nft <= last_lt_nft:
                    continue

                for ac in ev['actions']:
                    types = ac['type']

                    if types != "NftItemTransfer":
                       continue
                # Get value of transaction (how much NanoTONs have we received)
                    else:
                        new_nft = str(ac['NftItemTransfer']['nft'])
                        addr = str(account_forms(ac['NftItemTransfer']['sender']['address']))
                        nft_info = requests.get(f'https://tonapi.io/v2/nfts/{new_nft}?'
                                f'account_id={new_nft}&'
                                f'api_key= "{config.TON_API_KEY}"').json()
                        new_nft_name = nft_info['metadata']['name']
                        new_nft_des = nft_info['metadata']['description']   
                        new_nft_img = nft_info['metadata']['image']
                        uid = int(db.check_addr(addr))
                        db.add_nft(uid, new_nft, new_nft_name, new_nft_img, new_nft_des)

                # Send a message to user
                        nft_img = requests.get(new_nft_img)
                        

                        nft_detail = "Name: " + new_nft_name + "\nDescription:\n" + new_nft_des   
                        await bot.send_message(uid, 'NFT received!\n',
                                           parse_mode=ParseMode.HTML)
                        try:
                            if nft_img.headers['content-type'] == 'image/gif' or nft_img.headers['content-type'] == 'video/mp4':
                                await bot.send_animation(uid, animation = new_nft_img, caption = nft_detail)
                            else:
                                await bot.send_photo(uid, photo = nft_img.content, caption = nft_detail)
                        except:
                            try:
                                await bot.send_message(uid, f'Error retrieving image, file too large or not supported.\n{nft_detail}', parse_mode=ParseMode.HTML)
                            except:
                                await bot.send_message(uid, 'Error retrieving metadata, please contact the NFT issuer.', parse_mode=ParseMode.HTML)

            # After we processed new transaction, last_lt must be updated
                last_lt_nft = lt_nft
                with open('last_lt_nft.txt', 'w') as f:
                     f.write(str(last_lt_nft))
        except:
            continue
